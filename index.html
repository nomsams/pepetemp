<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PepeChat — ICE Fallback v14</title>

  <!-- DNS prefetch to reduce STUN hostname lookup latency (best-effort) -->
  <link rel="dns-prefetch" href="//stun.l.google.com">
  <link rel="dns-prefetch" href="//stun1.l.google.com">
  <link rel="dns-prefetch" href="//stun2.l.google.com">
  <link rel="dns-prefetch" href="//stun3.l.google.com">
  <link rel="dns-prefetch" href="//stun4.l.google.com">
  <link rel="dns-prefetch" href="//global.stun.twilio.com">
  <link rel="dns-prefetch" href="//stun.stunprotocol.org">

  <style>
    :root{
      --bg:#0b0d12; --panel:#121626; --panel2:#0f1320; --line:#242a3c;
      --text:#e8ecff; --muted:#a8b0d6; --accent:#7aa2ff; --bad:#ff6b6b; --good:#44d19a;
      --warn:#ffce5c;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{margin:0; background:var(--bg); color:var(--text); font-family:var(--sans);}
    .app{display:grid; grid-template-columns: 340px 1fr; height:100vh;}
    .sidebar{border-right:1px solid var(--line); background:linear-gradient(180deg,var(--panel),var(--panel2)); padding:14px; overflow:auto;}
    .main{display:grid; grid-template-rows: auto 1fr auto; height:100vh;}
    .topbar{border-bottom:1px solid var(--line); padding:12px 14px; display:flex; gap:12px; align-items:center; justify-content:space-between; background:rgba(18,22,38,.9); backdrop-filter: blur(6px);}
    .status{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .pill{display:inline-flex; gap:8px; align-items:center; border:1px solid var(--line); padding:6px 10px; border-radius:999px; font-size:12px; color:var(--muted);}
    .dot{width:8px; height:8px; border-radius:99px; background:var(--muted);}
    .dot.good{background:var(--good)} .dot.bad{background:var(--bad)} .dot.warn{background:var(--warn)}
    .btn{background:transparent; color:var(--text); border:1px solid var(--line); padding:8px 10px; border-radius:10px; cursor:pointer; font-size:13px;}
    .btn:hover{border-color:#3a4464}
    .btn.primary{background:rgba(122,162,255,.14); border-color:rgba(122,162,255,.35);}
    .btn.bad{background:rgba(255,107,107,.14); border-color:rgba(255,107,107,.35);}
    .btn.good{background:rgba(68,209,154,.12); border-color:rgba(68,209,154,.35);}
    .btn:disabled{opacity:.45; cursor:not-allowed}
    .section{border:1px solid var(--line); border-radius:14px; padding:12px; margin:10px 0; background:rgba(15,19,32,.55);}
    .section h3{margin:0 0 10px 0; font-size:13px; letter-spacing:.02em; color:var(--muted); text-transform:uppercase;}
    label{display:block; font-size:12px; color:var(--muted); margin:10px 0 6px;}
    input, textarea, select{
      width:100%; padding:10px 10px; border-radius:12px; border:1px solid var(--line);
      background:#0b0f1a; color:var(--text); outline:none;
      font-family:var(--sans); font-size:13px;
    }
    textarea{min-height:88px; resize:vertical; font-family:var(--mono); font-size:12px;}
    .row{display:flex; gap:10px;}
    .row > *{flex:1}
    .tiny{font-size:12px; color:var(--muted); line-height:1.35;}
    .chatList{display:flex; flex-direction:column; gap:8px; margin-top:10px;}
    .chatItem{border:1px solid var(--line); border-radius:14px; padding:10px; cursor:pointer; background:rgba(11,15,26,.55);}
    .chatItem:hover{border-color:#3a4464}
    .chatItem .title{font-weight:650; font-size:13px;}
    .chatItem .sub{font-size:12px; color:var(--muted); margin-top:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .chatItem.active{border-color:rgba(122,162,255,.55); background:rgba(122,162,255,.10);}
    .chat{padding:12px 14px; overflow:auto;}
    .bubble{max-width: 860px; border:1px solid var(--line); border-radius:16px; padding:10px 12px; margin:8px 0; background:rgba(11,15,26,.55);}
    .bubble.me{margin-left:auto; border-color:rgba(122,162,255,.35); background:rgba(122,162,255,.10);}
    .meta{display:flex; gap:10px; align-items:center; justify-content:space-between; font-size:12px; color:var(--muted); margin-bottom:6px;}
    .text{white-space:pre-wrap; word-wrap:break-word; font-size:14px; line-height:1.35;}
    .composer{border-top:1px solid var(--line); padding:12px 14px; background:rgba(18,22,38,.85); backdrop-filter: blur(6px);}
    .composer .row{align-items:center}
    .composer input[type="file"]{padding:8px; background:#0b0f1a;}
    .logWrap{border-top:1px solid var(--line); background:rgba(15,19,32,.55); padding:10px 14px;}
    .log{font-family:var(--mono); font-size:12px; color:#cbd3ff; max-height:180px; overflow:auto; white-space:pre-wrap;}
    .warnText{color:var(--warn)}
    .badText{color:var(--bad)}
    .goodText{color:var(--good)}
    .qrBox{display:grid; grid-template-columns: 1fr 140px; gap:10px; align-items:start;}
    .qrCanvas{width:140px; height:140px; border:1px solid var(--line); border-radius:14px; display:flex; align-items:center; justify-content:center; background:#0b0f1a;}
    .kbd{font-family:var(--mono); font-size:11px; padding:1px 6px; border:1px solid var(--line); border-bottom-width:2px; border-radius:8px; color:var(--muted);}
    .modal{position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; padding:20px;}
    .modal.open{display:flex}
    .modalCard{width:min(980px, 96vw); background:rgba(18,22,38,.98); border:1px solid var(--line); border-radius:18px; padding:14px;}
    .modalTop{display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom:10px;}
    canvas{border:1px solid var(--line); border-radius:14px; background:#0b0f1a; width:100%; height:520px;}
  </style>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>
</head>

<body>
<div class="app">
  <aside class="sidebar">
    <div class="section">
      <h3>Identity</h3>
      <label>Your ID</label>
      <input id="myId" placeholder="e.g., user-34742" />
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="btnStart">Start</button>
        <button class="btn" id="btnRandom">Random ID</button>
      </div>
      <div class="tiny" style="margin-top:10px;">
        Tip: If you are on a restrictive network, reliability typically requires a TURN server (TCP/TLS on port 443).
        This app includes extensive ICE fallbacks and will log exactly what it tried.
      </div>
    </div>

    <div class="section">
      <h3>Connect</h3>
      <label>Peer ID to connect</label>
      <input id="connectId" placeholder="e.g., user-84307" />
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="btnConnect">Connect</button>
        <button class="btn" id="btnQR">QR Link</button>
      </div>

      <div id="qrArea" style="margin-top:10px; display:none;">
        <div class="qrBox">
          <div>
            <div class="tiny">Scan the QR (or copy the URL) on the other device.</div>
            <label>Invite URL</label>
            <input id="inviteUrl" readonly />
            <div class="row" style="margin-top:10px;">
              <button class="btn" id="btnCopyInvite">Copy</button>
              <button class="btn" id="btnNewKey">New Key</button>
            </div>
            <div class="tiny" style="margin-top:10px;">
              Encryption key is embedded in the URL parameter <span class="kbd">k=</span>. Anyone with that URL can join.
            </div>
          </div>
          <div class="qrCanvas" id="qrCanvas"></div>
        </div>
      </div>
    </div>

    <div class="section">
      <h3>Chats</h3>
      <div class="chatList" id="chatList"></div>
      <div class="tiny" style="margin-top:10px;">
        Chat history is stored locally (per browser). Files are not persisted; they are session-only.
      </div>
    </div>

    <div class="section">
      <h3>ICE / NAT traversal</h3>

      <label>ICE profile</label>
      <select id="iceProfile"></select>

      <div class="row" style="margin-top:10px;">
        <button class="btn" id="btnTryNextIce">Try next profile</button>
        <button class="btn" id="btnIceProbe">Probe profile</button>
      </div>

      <label style="margin-top:12px;">Custom TURN/STUN (optional)</label>
      <textarea id="customIce" placeholder='Example:
stun:stun.l.google.com:19302
turns:turn.example.com:443?transport=tcp | user | pass
turn:turn.example.com:80?transport=tcp | user | pass
'></textarea>

      <div class="row" style="margin-top:10px;">
        <button class="btn" id="btnSaveCustomIce">Save</button>
        <button class="btn" id="btnClearCustomIce">Clear</button>
      </div>

      <div class="tiny" style="margin-top:10px;">
        Custom ICE format:
        <br>• STUN line: <span class="kbd">stun:host:port</span>
        <br>• TURN line: <span class="kbd">turn(s):host:port?... | username | password</span>
        <br><br>
        If STUN host lookup fails or STUN binding times out, your network may block DNS/UDP to STUN.
        In that case, use TURN over TCP/TLS on port 443.
      </div>
    </div>

    <div class="section">
      <h3>Security</h3>
      <div class="row">
        <button class="btn" id="btnToggleEnc">Encryption: ON</button>
        <button class="btn" id="btnRotateKey">Rotate key</button>
      </div>
      <div class="tiny" style="margin-top:10px;">
        Uses NaCl secretbox (symmetric). Key is shared out-of-band (QR/URL).
      </div>
    </div>

    <div class="section">
      <h3>Signaling server</h3>
      <div class="tiny">PeerJS signaling can be a failure point. You may point this to your own PeerJS server for production use.</div>
      <label>Host</label>
      <input id="sigHost" placeholder="0.peerjs.com" />
      <div class="row">
        <div>
          <label>Port</label>
          <input id="sigPort" placeholder="443" />
        </div>
        <div>
          <label>Secure</label>
          <select id="sigSecure">
            <option value="true">true</option>
            <option value="false">false</option>
          </select>
        </div>
      </div>
      <label>Path</label>
      <input id="sigPath" placeholder="/" />
      <div class="row" style="margin-top:10px;">
        <button class="btn" id="btnSaveSig">Save</button>
        <button class="btn" id="btnResetSig">Reset</button>
      </div>
    </div>

  </aside>

  <main class="main">
    <div class="topbar">
      <div class="status">
        <div class="pill"><span class="dot" id="dotPeer"></span> <span id="peerState">Not started</span></div>
        <div class="pill"><span class="dot" id="dotWebrtc"></span> <span id="webrtcState">WebRTC: unknown</span></div>
        <div class="pill"><span class="dot" id="dotEnc"></span> <span id="encState">Encryption: ON</span></div>
        <div class="pill"><span class="dot" id="dotIce"></span> <span id="iceState">ICE: not configured</span></div>
      </div>
      <div style="display:flex; gap:10px; align-items:center;">
        <button class="btn" id="btnExportLog">Export log</button>
        <button class="btn bad" id="btnResetApp">Reset app</button>
      </div>
    </div>

    <div class="chat" id="chat"></div>

    <div class="composer">
      <div class="row">
        <input id="msg" placeholder="Type a message…" />
        <button class="btn primary" id="btnSend">Send</button>
      </div>
      <div class="row" style="margin-top:10px;">
        <input id="file" type="file" />
        <button class="btn" id="btnSendFile">Send file</button>
        <button class="btn" id="btnDraw">Draw</button>
      </div>
      <div class="tiny" style="margin-top:10px;">
        Connection tip: If you see repeated <span class="kbd">701 STUN host lookup received error</span> or <span class="kbd">STUN binding request timed out</span>,
        your network is likely blocking DNS/UDP. Configure TURN (TCP/TLS on 443) in Custom ICE.
      </div>
    </div>

    <div class="logWrap">
      <div class="log" id="log"></div>
    </div>
  </main>
</div>

<!-- Drawing modal -->
<div class="modal" id="drawModal" role="dialog" aria-modal="true">
  <div class="modalCard">
    <div class="modalTop">
      <div style="display:flex; gap:10px; align-items:center;">
        <strong>Quick Draw</strong>
        <span class="tiny">Send as image to the active chat.</span>
      </div>
      <div style="display:flex; gap:10px;">
        <button class="btn" id="btnClearDraw">Clear</button>
        <button class="btn good" id="btnSendDraw">Send drawing</button>
        <button class="btn" id="btnCloseDraw">Close</button>
      </div>
    </div>
    <canvas id="drawCanvas" width="1400" height="900"></canvas>
    <div class="tiny" style="margin-top:10px;">
      Tip: Use mouse or touch. The canvas is local-only until you press “Send drawing”.
    </div>
  </div>
</div>

<script>
(() => {
  'use strict';

  // =========================
  // Version
  // =========================
  const APP_VERSION = 'ICE_Fallback_v14';

  // =========================
  // DOM helpers
  // =========================
  const $ = (id) => document.getElementById(id);

  // =========================
  // State
  // =========================
  let peer = null;
  let myId = '';
  let activePeerId = null;
  let encryptionOn = true;

  // 32-byte key for secretbox (shared via URL/QR)
  let roomKey = null;

  // chat store
  const chats = new Map(); // peerId -> {peerId, conn, messages:[], lastPreview, lastTs}

  // logs
  const logLines = [];
  const MAX_LOG_LINES = 1500;

  // =========================
  // Logging
  // =========================
  function log(msg, cls='') {
    const ts = new Date().toLocaleTimeString();
    const line = `[${ts}] ${msg}`;
    logLines.push({line, cls});
    while (logLines.length > MAX_LOG_LINES) logLines.shift();

    const el = $('log');
    el.textContent = logLines.map(x => x.line).join('\n');
    el.scrollTop = el.scrollHeight;
    console.log(line);
  }

  function setPill(dotEl, textEl, status, text) {
    const dot = $(dotEl);
    const t = $(textEl);
    dot.className = 'dot ' + (status || '');
    t.textContent = text;
  }

  // =========================
  // Storage
  // =========================
  const LS = {
    get(k, fallback=null){ try{ const v = localStorage.getItem(k); return v==null?fallback:JSON.parse(v);}catch{ return fallback; } },
    set(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch{} },
    del(k){ try{ localStorage.removeItem(k); }catch{} },
  };

  // =========================
  // Base64URL
  // =========================
  function b64urlEncode(u8) {
    const b64 = nacl.util.encodeBase64(u8);
    return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }
  function b64urlDecodeToU8(s) {
    const b64 = s.replace(/-/g,'+').replace(/_/g,'/');
    const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
    return nacl.util.decodeBase64(b64 + pad);
  }

  // =========================
  // Crypto helpers
  // =========================
  function ensureRoomKey() {
    if (roomKey && roomKey.length === 32) return roomKey;
    const saved = LS.get('pepechat_roomKey_b64url', null);
    if (saved) {
      try {
        const k = b64urlDecodeToU8(saved);
        if (k.length === 32) {
          roomKey = k;
          return roomKey;
        }
      } catch {}
    }
    roomKey = nacl.randomBytes(32);
    LS.set('pepechat_roomKey_b64url', b64urlEncode(roomKey));
    return roomKey;
  }

  function rotateRoomKey() {
    roomKey = nacl.randomBytes(32);
    LS.set('pepechat_roomKey_b64url', b64urlEncode(roomKey));
    log('Rotated encryption key. Re-generate your QR/Invite URL and re-connect.', 'warn');
    renderInviteIfOpen();
  }

  function encryptBytes(plainU8) {
    const key = ensureRoomKey();
    const nonce = nacl.randomBytes(24);
    const box = nacl.secretbox(plainU8, nonce, key);
    return { nonceB64: b64urlEncode(nonce), boxU8: box };
  }

  function decryptBytes(nonceB64, boxU8) {
    const key = ensureRoomKey();
    const nonce = b64urlDecodeToU8(nonceB64);
    const plain = nacl.secretbox.open(boxU8, nonce, key);
    if (!plain) throw new Error('Decrypt failed (wrong key?)');
    return plain;
  }

  // =========================
  // ICE profiles
  // =========================
  function dedupeUrls(urls) {
    const out = [];
    const s = new Set();
    for (const u of urls) {
      const v = String(u || '').trim();
      if (!v) continue;
      if (s.has(v)) continue;
      s.add(v); out.push(v);
    }
    return out;
  }

  function baseIceProfiles() {
    // Note: many public STUN endpoints are best-effort and may disappear.
    // This list is intentionally diverse, and we rotate through profiles.
    return [
      {
        name: 'Balanced STUN (multi-provider)',
        rtcConfig: {
          iceServers: [
            { urls: dedupeUrls([
              'stun:stun.l.google.com:19302',
              'stun:stun1.l.google.com:19302',
              'stun:stun2.l.google.com:19302',
              'stun:stun3.l.google.com:19302',
              'stun:stun4.l.google.com:19302',
              'stun:global.stun.twilio.com:3478',
              'stun:stun.stunprotocol.org:3478'
            ])}
          ],
          iceCandidatePoolSize: 4
        }
      },
      {
        name: 'Aggressive STUN (broad legacy pool)',
        rtcConfig: {
          iceServers: [
            { urls: dedupeUrls([
              'stun:stun.l.google.com:19302',
              'stun:stun1.l.google.com:19302',
              'stun:stun2.l.google.com:19302',
              'stun:stun3.l.google.com:19302',
              'stun:stun4.l.google.com:19302',
              'stun:global.stun.twilio.com:3478',
              'stun:stun.stunprotocol.org:3478',
              'stun:stun.iptel.org:3478',
              'stun:stun.ideasip.com:3478',
              'stun:stun.sipgate.net:3478',
              'stun:stun.voiparound.com:3478',
              'stun:stun.voipbuster.com:3478',
              'stun:stun.12voip.com:3478',
              'stun:stun.voip.blackberry.com:3478'
            ])}
          ],
          iceCandidatePoolSize: 6
        }
      },
      {
        name: 'Minimal STUN (Google only)',
        rtcConfig: {
          iceServers: [
            { urls: dedupeUrls([
              'stun:stun.l.google.com:19302',
              'stun:stun1.l.google.com:19302',
              'stun:stun2.l.google.com:19302'
            ])}
          ],
          iceCandidatePoolSize: 2
        }
      },
      {
        name: 'Host-only (no STUN/TURN)',
        rtcConfig: {
          iceServers: [],
          iceCandidatePoolSize: 0
        }
      }
    ];
  }

  function parseCustomIce(text) {
    const lines = String(text || '').split('\n').map(x=>x.trim()).filter(Boolean);
    const servers = [];
    for (const ln of lines) {
      // TURN with creds:  turn(s):host:port?... | user | pass
      const parts = ln.split('|').map(x=>x.trim()).filter(Boolean);
      if (parts.length >= 3) {
        const url = parts[0];
        const username = parts[1];
        const credential = parts.slice(2).join(' | ');
        servers.push({ urls: url, username, credential });
        continue;
      }
      // STUN: no creds
      if (ln.startsWith('stun:') || ln.startsWith('stuns:') || ln.startsWith('turn:') || ln.startsWith('turns:')) {
        servers.push({ urls: ln });
      }
    }
    // Normalize & dedupe by URL+user
    const seen = new Set();
    const out = [];
    for (const s of servers) {
      const key = `${s.urls}||${s.username||''}`;
      if (seen.has(key)) continue;
      seen.add(key);
      out.push(s);
    }
    return out;
  }

  function buildRuntimeIceProfiles() {
    const profiles = [];

    const customText = LS.get('pepechat_custom_ice', '');
    const customServers = parseCustomIce(customText);

    const hasTurn = customServers.some(s => String(s.urls).startsWith('turn'));
    const hasStun = customServers.some(s => String(s.urls).startsWith('stun'));

    if (customServers.length) {
      // Relay-only is extremely useful when UDP is blocked and you have TURN/TLS on 443.
      profiles.push({
        name: hasTurn ? 'Custom (TURN relay-only first)' : 'Custom (no TURN) — best-effort',
        rtcConfig: {
          iceServers: customServers,
          iceTransportPolicy: hasTurn ? 'relay' : 'all',
          iceCandidatePoolSize: 4
        }
      });

      // Also allow custom as "all" to combine srflx/host with relay.
      if (hasTurn) {
        profiles.push({
          name: 'Custom (TURN + direct; policy=all)',
          rtcConfig: {
            iceServers: customServers,
            iceTransportPolicy: 'all',
            iceCandidatePoolSize: 4
          }
        });
      }

      // If user provided only TURN (no STUN), add a mixed profile by appending safe STUN.
      if (hasTurn && !hasStun) {
        profiles.push({
          name: 'Custom TURN + fallback STUN (mixed)',
          rtcConfig: {
            iceServers: [
              ...customServers,
              { urls: dedupeUrls([
                'stun:stun.l.google.com:19302',
                'stun:global.stun.twilio.com:3478'
              ])}
            ],
            iceTransportPolicy: 'all',
            iceCandidatePoolSize: 6
          }
        });
      }
    }

    // Base profiles at the end
    profiles.push(...baseIceProfiles());

    return profiles;
  }

  let runtimeIceProfiles = [];
  let iceProfileIndex = 0;

  function loadIceProfileIndex() {
    const v = LS.get('pepechat_ice_profile_index', 0);
    iceProfileIndex = Number.isFinite(v) ? Math.max(0, v) : 0;
  }

  function saveIceProfileIndex() {
    LS.set('pepechat_ice_profile_index', iceProfileIndex);
  }

  function applyIceProfileByIndex(idx, reason='') {
    runtimeIceProfiles = buildRuntimeIceProfiles();
    if (!runtimeIceProfiles.length) runtimeIceProfiles = baseIceProfiles();
    iceProfileIndex = Math.max(0, Math.min(idx, runtimeIceProfiles.length - 1));
    saveIceProfileIndex();

    const profile = runtimeIceProfiles[iceProfileIndex];
    const name = profile?.name || 'unknown';
    setPill('dotIce','iceState','warn',`ICE: ${name}`);
    log(`ICE profile set: "${name}"${reason ? ` (${reason})` : ''}`);

    // Apply to PeerJS options for new connections.
    // PeerJS reads options.config when creating RTCPeerConnection for a DataConnection.
    if (peer && peer.options) {
      try { peer.options.config = profile.rtcConfig; } catch {}
      try { peer._options && (peer._options.config = profile.rtcConfig); } catch {}
      try { peer.options.iceServers = profile.rtcConfig.iceServers; } catch {}
    }

    // Update UI dropdown to match
    const sel = $('iceProfile');
    if (sel) sel.value = String(iceProfileIndex);
  }

  // =========================
  // PeerJS signaling settings
  // =========================
  function loadSigSettings() {
    const d = LS.get('pepechat_sig', null);
    if (d && typeof d === 'object') return d;
    return { host: '0.peerjs.com', port: 443, path: '/', secure: true };
  }
  function saveSigSettings(s) { LS.set('pepechat_sig', s); }

  // =========================
  // Peer init
  // =========================
  function isWebrtcAvailable() {
    return !!(window.RTCPeerConnection && window.RTCDataChannel);
  }

  function randomUserId() {
    return `user-${Math.floor(10000 + Math.random() * 90000)}`;
  }

  async function startPeer(forceId = null) {
    if (!isWebrtcAvailable()) {
      setPill('dotWebrtc','webrtcState','bad','WebRTC: unavailable');
      log('WebRTC is not available in this browser/context. P2P cannot work here.', 'bad');
      return;
    }
    setPill('dotWebrtc','webrtcState','good','WebRTC: available');

    myId = String(forceId || $('myId').value || '').trim() || randomUserId();
    $('myId').value = myId;

    // Ensure key exists
    ensureRoomKey();

    // Build ICE profiles now
    runtimeIceProfiles = buildRuntimeIceProfiles();
    loadIceProfileIndex();
    applyIceProfileByIndex(Math.min(iceProfileIndex, runtimeIceProfiles.length-1), 'startup');

    // Signaling settings
    const sig = loadSigSettings();

    if (peer) {
      try { peer.destroy(); } catch {}
      peer = null;
    }

    log(`Initializing PeerJS with ID: ${myId}`);
    setPill('dotPeer','peerState','warn','Starting…');

    // Create PeerJS peer
    const profile = runtimeIceProfiles[iceProfileIndex] || baseIceProfiles()[0];

    peer = new Peer(myId, {
      host: sig.host,
      port: Number(sig.port),
      path: sig.path,
      secure: !!sig.secure,
      debug: 2,
      config: profile.rtcConfig
    });

    peer.on('open', (id) => {
      setPill('dotPeer','peerState','good',`Online: ${id}`);
      log(`PeerJS ready. Your ID: ${id}`);
      renderInviteIfOpen();

      // Auto-connect if URL includes ?connect=...&k=...
      handleAutoConnectFromUrl();
    });

    peer.on('connection', (conn) => {
      log(`Incoming connection from ${conn.peer}`);
      bindConnection(conn, {incoming:true});
    });

    peer.on('disconnected', () => {
      setPill('dotPeer','peerState','warn','Disconnected (signaling)');
      log('PeerJS disconnected from signaling server. Attempting reconnect…', 'warn');
      try { peer.reconnect(); } catch {}
    });

    peer.on('close', () => {
      setPill('dotPeer','peerState','bad','Closed');
      log('PeerJS closed.', 'bad');
    });

    peer.on('error', (err) => {
      setPill('dotPeer','peerState','bad','Error');
      log(`PeerJS error: ${err?.type || 'unknown'} — ${err?.message || err}`, 'bad');
    });
  }

  // =========================
  // Connection with ICE fallback
  // =========================
  function getOrCreateChat(peerId) {
    if (!chats.has(peerId)) {
      chats.set(peerId, { peerId, conn: null, messages: [], lastPreview: '', lastTs: 0 });
    }
    return chats.get(peerId);
  }

  function setActiveChat(peerId) {
    activePeerId = peerId;
    renderChatList();
    renderChat();
  }

  function getPcFromConn(conn) {
    // PeerJS has varied internal property names across versions
    return conn.peerConnection || conn._pc || conn._peerConnection || null;
  }

  function attachPcDiagnostics(conn) {
    const peerId = conn.peer;

    const tryAttach = () => {
      const pc = getPcFromConn(conn);
      if (!pc) return false;

      pc.addEventListener('icecandidateerror', (e) => {
        // Some browsers provide: url, errorCode, errorText, hostCandidate
        const code = e.errorCode ?? 'unknown';
        const text = e.errorText ?? '';
        const url = e.url ? ` url=${e.url}` : '';
        const hostCand = e.hostCandidate ? ` hostCandidate=${e.hostCandidate}` : '';
        log(`ICE Candidate Error (${peerId}): ${code} ${text}${url}${hostCand}`, 'bad');
      });

      pc.addEventListener('iceconnectionstatechange', () => {
        log(`ICE State (${peerId}): ${pc.iceConnectionState}`);
        if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
          log(`ICE state is "${pc.iceConnectionState}" for ${peerId}. You can try the next ICE profile, or configure TURN (TCP/TLS 443).`, 'warn');
        }
      });

      pc.addEventListener('connectionstatechange', () => {
        log(`PC State (${peerId}): ${pc.connectionState}`);
      });

      pc.addEventListener('signalingstatechange', () => {
        log(`Signaling State (${peerId}): ${pc.signalingState}`);
      });

      pc.addEventListener('icegatheringstatechange', () => {
        log(`ICE Gathering (${peerId}): ${pc.iceGatheringState}`);
      });

      return true;
    };

    if (!tryAttach()) {
      const iv = setInterval(() => {
        if (tryAttach()) clearInterval(iv);
      }, 150);
      setTimeout(() => clearInterval(iv), 5000);
    }
  }

  function bindConnection(conn, {incoming=false} = {}) {
    const peerId = conn.peer;
    const chat = getOrCreateChat(peerId);

    // If we already have a connection, keep the newest OPEN one and close duplicates
    if (chat.conn && chat.conn !== conn) {
      log(`Duplicate connection with ${peerId}. Replacing existing connection.`, 'warn');
      try { chat.conn.close(); } catch {}
      chat.conn = null;
    }

    chat.conn = conn;
    setActiveChat(peerId);

    attachPcDiagnostics(conn);

    conn.on('open', () => {
      log(`DataConnection open with ${peerId}${incoming ? ' (incoming)' : ''}`, 'good');
      chat.lastPreview = 'Connected';
      chat.lastTs = Date.now();
      renderChatList();
      systemMsg(peerId, `Connected to ${peerId}.`);
    });

    conn.on('data', (data) => {
      handleIncoming(peerId, data);
    });

    conn.on('close', () => {
      log(`Connection closed with ${peerId}`, 'warn');
      systemMsg(peerId, `Disconnected from ${peerId}.`);
      chat.conn = null;
      renderChatList();
    });

    conn.on('error', (err) => {
      log(`Connection error with ${peerId}: ${err?.type || 'unknown'} — ${err?.message || err}`, 'bad');
    });
  }

  function waitForConnOpen(conn, timeoutMs=15000) {
    return new Promise((resolve, reject) => {
      let done = false;
      const t = setTimeout(() => {
        if (done) return;
        done = true;
        reject(new Error('timeout'));
      }, timeoutMs);

      conn.on('open', () => {
        if (done) return;
        done = true;
        clearTimeout(t);
        resolve(true);
      });

      conn.on('error', (err) => {
        if (done) return;
        done = true;
        clearTimeout(t);
        reject(err || new Error('connection error'));
      });

      conn.on('close', () => {
        if (done) return;
        done = true;
        clearTimeout(t);
        reject(new Error('closed'));
      });
    });
  }

  async function connectWithIceFallback(peerId) {
    if (!peer) {
      log('Start PeerJS first.', 'warn');
      return;
    }
    peerId = String(peerId || '').trim();
    if (!peerId) return;

    setActiveChat(peerId);
    const chat = getOrCreateChat(peerId);

    // If already open, do nothing
    if (chat.conn && chat.conn.open) {
      log(`Already connected to ${peerId}.`);
      return;
    }

    runtimeIceProfiles = buildRuntimeIceProfiles();
    if (!runtimeIceProfiles.length) runtimeIceProfiles = baseIceProfiles();

    // Attempt starting from current profile, then rotate through the rest
    const startIdx = iceProfileIndex;
    const tryOrder = [];
    for (let i = 0; i < runtimeIceProfiles.length; i++) {
      tryOrder.push((startIdx + i) % runtimeIceProfiles.length);
    }

    log(`Connecting to ${peerId} with ICE fallback (${tryOrder.length} profiles)…`);
    for (const idx of tryOrder) {
      applyIceProfileByIndex(idx, 'connect-attempt');

      const profile = runtimeIceProfiles[idx];
      const profileName = profile?.name || 'unknown';

      log(`Attempt: ${peerId} using ICE profile "${profileName}"`);

      // Close any stale connection object
      if (chat.conn) {
        try { chat.conn.close(); } catch {}
        chat.conn = null;
      }

      let conn;
      try {
        conn = peer.connect(peerId, { reliable: true, serialization: 'binary' });
      } catch (e) {
        log(`peer.connect failed immediately: ${e?.message || e}`, 'bad');
        continue;
      }

      bindConnection(conn, {incoming:false});

      try {
        await waitForConnOpen(conn, 16000);
        log(`Connected to ${peerId} successfully using "${profileName}".`, 'good');
        return;
      } catch (e) {
        const msg = (e && e.message) ? e.message : String(e || 'unknown');
        log(`Attempt failed with "${profileName}": ${msg}`, 'warn');

        // If we see STUN/TURN lookup errors or timeouts, try next quickly.
        try { conn.close(); } catch {}

        // Short cooldown
        await new Promise(r => setTimeout(r, 650));
      }
    }

    log(`All ICE profiles failed for ${peerId}.`, 'bad');
    log(`If you are on CGNAT/symmetric NAT or UDP-blocked networks, you will need a TURN server (TCP/TLS on 443).`, 'warn');
    log(`As a last resort, "Host-only (no STUN/TURN)" can work only on the same LAN or very permissive NATs.`, 'warn');
  }

  // =========================
  // Messaging (text + files)
  // =========================
  function pushMessage(peerId, m) {
    const chat = getOrCreateChat(peerId);
    chat.messages.push(m);
    chat.lastTs = m.ts || Date.now();
    chat.lastPreview = m.kind === 'text' ? (m.text || '').slice(0, 120) :
                      m.kind === 'file' ? `File: ${m.name || 'unknown'}` :
                      m.kind === 'system' ? (m.text || '').slice(0, 120) : '';
    persistChat(peerId);
    renderChatList();
    if (peerId === activePeerId) renderChat();
  }

  function systemMsg(peerId, text) {
    pushMessage(peerId, { id: crypto.randomUUID(), kind: 'system', from: 'system', text, ts: Date.now() });
  }

  function persistChat(peerId) {
    const chat = getOrCreateChat(peerId);
    // Persist only messages metadata/content for text/system; files are not persisted.
    const persist = {
      peerId: chat.peerId,
      lastPreview: chat.lastPreview,
      lastTs: chat.lastTs,
      messages: chat.messages
        .filter(m => m.kind !== 'file')
        .slice(-400)
    };
    const all = LS.get('pepechat_chats', {});
    all[peerId] = persist;
    LS.set('pepechat_chats', all);
  }

  function loadChatsFromStorage() {
    const all = LS.get('pepechat_chats', {});
    for (const [peerId, c] of Object.entries(all || {})) {
      chats.set(peerId, {
        peerId,
        conn: null,
        messages: Array.isArray(c.messages) ? c.messages : [],
        lastPreview: c.lastPreview || '',
        lastTs: c.lastTs || 0
      });
    }
  }

  function getActiveConn() {
    if (!activePeerId) return null;
    const chat = chats.get(activePeerId);
    return chat?.conn || null;
  }

  function sendJson(conn, obj) {
    conn.send(obj);
  }

  function sendText() {
    const conn = getActiveConn();
    const text = $('msg').value;
    if (!activePeerId) { log('Select or connect to a peer first.', 'warn'); return; }
    if (!conn || !conn.open) { log('No active connection. Connect first.', 'warn'); return; }
    if (!text.trim()) return;

    const ts = Date.now();
    const id = crypto.randomUUID();

    // Local echo as plaintext
    pushMessage(activePeerId, { id, kind:'text', from:'me', text, ts });

    const payload = { t:'m', id, ts, enc: false, text };

    if (encryptionOn) {
      const bytes = nacl.util.decodeUTF8(text);
      const { nonceB64, boxU8 } = encryptBytes(bytes);
      payload.enc = true;
      payload.nonce = nonceB64;
      payload.box = boxU8.buffer;
      delete payload.text;
    }

    try {
      sendJson(conn, payload);
      $('msg').value = '';
    } catch (e) {
      log(`Send failed: ${e?.message || e}`, 'bad');
    }
  }

  // File transfer (chunked)
  const FILE_CHUNK = 16 * 1024; // 16KB
  const incomingFiles = new Map(); // id -> {meta, chunks: Map(seq->Uint8Array), receivedBytes}

  async function sendFile() {
    const conn = getActiveConn();
    const f = $('file').files?.[0];
    if (!activePeerId) { log('Select or connect to a peer first.', 'warn'); return; }
    if (!conn || !conn.open) { log('No active connection. Connect first.', 'warn'); return; }
    if (!f) { log('Choose a file first.', 'warn'); return; }

    const id = crypto.randomUUID();
    const total = Math.ceil(f.size / FILE_CHUNK);

    // Local message
    pushMessage(activePeerId, { id, kind:'file', from:'me', name:f.name, size:f.size, mime:f.type, ts:Date.now() });

    const meta = { t:'fmeta', id, name:f.name, size:f.size, mime:f.type || 'application/octet-stream', total, enc: !!encryptionOn };
    try { sendJson(conn, meta); } catch(e){ log(`Send meta failed: ${e?.message || e}`, 'bad'); return; }

    let offset = 0;
    for (let seq = 0; seq < total; seq++) {
      const slice = f.slice(offset, offset + FILE_CHUNK);
      const buf = new Uint8Array(await slice.arrayBuffer());
      offset += FILE_CHUNK;

      if (encryptionOn) {
        const { nonceB64, boxU8 } = encryptBytes(buf);
        sendJson(conn, { t:'fchunk', id, seq, total, enc:true, nonce: nonceB64, box: boxU8.buffer });
      } else {
        sendJson(conn, { t:'fchunk', id, seq, total, enc:false, data: buf.buffer });
      }

      // Simple pacing
      if (seq % 16 === 0) await new Promise(r => setTimeout(r, 0));
    }

    sendJson(conn, { t:'fend', id });
    $('file').value = '';
    log(`File sent: ${f.name} (${f.size} bytes)`);
  }

  function handleIncoming(peerId, data) {
    try {
      if (!data || typeof data !== 'object') {
        log(`Unknown data received from ${peerId} (non-object).`, 'warn');
        return;
      }

      if (data.t === 'm') {
        let text = data.text;
        if (data.enc) {
          const boxU8 = new Uint8Array(data.box);
          const plain = decryptBytes(data.nonce, boxU8);
          text = nacl.util.encodeUTF8(plain);
        }
        pushMessage(peerId, { id: data.id || crypto.randomUUID(), kind:'text', from:'peer', text, ts: data.ts || Date.now() });
        return;
      }

      if (data.t === 'fmeta') {
        incomingFiles.set(data.id, { meta: data, chunks: new Map(), receivedBytes: 0 });
        systemMsg(peerId, `Incoming file: ${data.name} (${data.size} bytes)`);
        return;
      }

      if (data.t === 'fchunk') {
        const rec = incomingFiles.get(data.id);
        if (!rec) return;

        let chunkU8;
        if (data.enc) {
          const boxU8 = new Uint8Array(data.box);
          chunkU8 = decryptBytes(data.nonce, boxU8);
        } else {
          chunkU8 = new Uint8Array(data.data);
        }
        rec.chunks.set(data.seq, chunkU8);
        rec.receivedBytes += chunkU8.length;
        return;
      }

      if (data.t === 'fend') {
        const rec = incomingFiles.get(data.id);
        if (!rec) return;
        const meta = rec.meta;

        // Assemble
        const total = meta.total || rec.chunks.size;
        const parts = [];
        for (let i=0; i<total; i++) {
          const u = rec.chunks.get(i);
          if (!u) { log(`File ${meta.name}: missing chunk ${i}/${total-1}`, 'bad'); return; }
          parts.push(u);
        }
        const blob = new Blob(parts, { type: meta.mime || 'application/octet-stream' });
        const url = URL.createObjectURL(blob);

        pushMessage(peerId, { id: meta.id, kind:'file', from:'peer', name: meta.name, size: meta.size, mime: meta.mime, url, ts: Date.now() });
        incomingFiles.delete(meta.id);
        log(`Received file: ${meta.name} (${meta.size} bytes)`, 'good');
        return;
      }

      log(`Unknown message type from ${peerId}: ${data.t}`, 'warn');
    } catch (e) {
      log(`Error handling incoming data: ${e?.message || e}`, 'bad');
    }
  }

  // =========================
  // UI rendering
  // =========================
  function renderChatList() {
    const wrap = $('chatList');
    wrap.innerHTML = '';
    const items = Array.from(chats.values()).sort((a,b) => (b.lastTs||0) - (a.lastTs||0));
    if (!items.length) {
      const d = document.createElement('div');
      d.className = 'tiny';
      d.textContent = 'No chats yet.';
      wrap.appendChild(d);
      return;
    }

    for (const c of items) {
      const el = document.createElement('div');
      el.className = 'chatItem' + (c.peerId === activePeerId ? ' active' : '');
      el.onclick = () => setActiveChat(c.peerId);

      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = c.peerId;

      const sub = document.createElement('div');
      sub.className = 'sub';
      const status = c.conn?.open ? '• connected' : '• offline';
      sub.textContent = `${status} — ${c.lastPreview || ''}`;

      el.appendChild(title);
      el.appendChild(sub);
      wrap.appendChild(el);
    }
  }

  function renderChat() {
    const wrap = $('chat');
    wrap.innerHTML = '';
    if (!activePeerId) {
      const d = document.createElement('div');
      d.className = 'tiny';
      d.textContent = 'Connect to a peer to start chatting.';
      wrap.appendChild(d);
      return;
    }
    const chat = getOrCreateChat(activePeerId);
    const msgs = chat.messages || [];
    for (const m of msgs) {
      const b = document.createElement('div');
      b.className = 'bubble' + (m.from === 'me' ? ' me' : '');
      const meta = document.createElement('div');
      meta.className = 'meta';
      const left = document.createElement('div');
      left.textContent = `${m.from === 'me' ? 'You' : (m.from === 'peer' ? chat.peerId : 'System')}`;
      const right = document.createElement('div');
      right.textContent = new Date(m.ts || Date.now()).toLocaleString();
      meta.appendChild(left); meta.appendChild(right);

      const body = document.createElement('div');
      body.className = 'text';

      if (m.kind === 'file') {
        const name = m.name || 'file';
        const size = (m.size != null) ? ` (${m.size} bytes)` : '';
        if (m.url) {
          const a = document.createElement('a');
          a.href = m.url;
          a.download = name;
          a.textContent = `Download: ${name}${size}`;
          a.style.color = 'var(--accent)';
          body.appendChild(a);
        } else {
          body.textContent = `File: ${name}${size}`;
        }
      } else {
        body.textContent = m.text || '';
      }

      b.appendChild(meta);
      b.appendChild(body);
      wrap.appendChild(b);
    }
    wrap.scrollTop = wrap.scrollHeight;
  }

  // =========================
  // QR / Invite URL
  // =========================
  function appBaseUrl() {
    return window.location.href.replace(window.location.search,'').replace(window.location.hash,'');
  }

  function inviteUrlFor(peerToConnect=null) {
    // If peerToConnect is null, this is an invite to connect to YOU.
    const k = b64urlEncode(ensureRoomKey());
    const id = peerToConnect ? encodeURIComponent(peerToConnect) : encodeURIComponent(myId);
    return `${appBaseUrl()}?connect=${id}&k=${encodeURIComponent(k)}&v=${encodeURIComponent(APP_VERSION)}`;
  }

  function renderInviteIfOpen() {
    if ($('qrArea').style.display === 'none') return;
    // Invite URL is always "connect to me"
    const url = inviteUrlFor(null);
    $('inviteUrl').value = url;

    // Render QR
    const box = $('qrCanvas');
    box.innerHTML = '';
    try {
      new QRCode(box, { text: url, width: 128, height: 128, correctLevel: QRCode.CorrectLevel.M });
    } catch (e) {
      box.textContent = 'QR error';
    }
  }

  function openQrArea() {
    if (!peer) { log('Start PeerJS first to generate a QR/Invite URL.', 'warn'); return; }
    $('qrArea').style.display = 'block';
    renderInviteIfOpen();
  }

  function closeQrArea() {
    $('qrArea').style.display = 'none';
  }

  function handleAutoConnectFromUrl() {
    const url = new URL(window.location.href);
    const connect = url.searchParams.get('connect');
    const k = url.searchParams.get('k');

    if (k) {
      try {
        const key = b64urlDecodeToU8(k);
        if (key.length === 32) {
          roomKey = key;
          LS.set('pepechat_roomKey_b64url', b64urlEncode(roomKey));
          log('Imported encryption key from URL (k=...).', 'good');
          updateEncPill();
          renderInviteIfOpen();
        } else {
          log('URL key (k=...) was not 32 bytes; ignoring.', 'warn');
        }
      } catch (e) {
        log(`Failed to parse key from URL: ${e?.message || e}`, 'warn');
      }
    }

    if (connect) {
      const peerId = decodeURIComponent(connect);
      // Clean URL (avoid reconnect loops on refresh)
      window.history.replaceState({}, '', appBaseUrl());
      $('connectId').value = peerId;
      log(`Auto-connect requested via URL: connect=${peerId}`);
      connectWithIceFallback(peerId);
    }
  }

  // =========================
  // ICE probe (diagnostic)
  // =========================
  async function probeCurrentIceProfile() {
    if (!isWebrtcAvailable()) { log('WebRTC unavailable; cannot probe.', 'bad'); return; }

    runtimeIceProfiles = buildRuntimeIceProfiles();
    const profile = runtimeIceProfiles[iceProfileIndex] || baseIceProfiles()[0];
    const name = profile.name;

    log(`Probing ICE profile "${name}" (best-effort)…`);
    let pc;
    try {
      pc = new RTCPeerConnection(profile.rtcConfig);
    } catch (e) {
      log(`Probe failed to create RTCPeerConnection: ${e?.message || e}`, 'bad');
      return;
    }

    const types = new Set();
    let errCount = 0;

    pc.addEventListener('icecandidateerror', (e) => {
      errCount++;
      const code = e.errorCode ?? 'unknown';
      const text = e.errorText ?? '';
      log(`Probe ICE error: ${code} ${text}`, 'warn');
    });

    pc.onicecandidate = (ev) => {
      const c = ev.candidate?.candidate || '';
      if (!c) return;
      // Candidate strings contain "typ host|srflx|relay"
      const m = c.match(/\btyp\s+(\w+)/);
      if (m && m[1]) types.add(m[1]);
    };

    pc.createDataChannel('probe');

    try {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
    } catch (e) {
      log(`Probe failed during offer/setLocalDescription: ${e?.message || e}`, 'bad');
      try { pc.close(); } catch {}
      return;
    }

    await new Promise(r => setTimeout(r, 3500));

    const typesArr = Array.from(types).sort();
    log(`Probe results for "${name}": candidate types = ${typesArr.join(', ') || '(none)'}; errors=${errCount}`);
    if (!typesArr.length || (typesArr.length === 1 && typesArr[0] === 'host')) {
      log(`Probe suggests no usable STUN/TURN path from this network. If remote is not on the same LAN, configure TURN over TCP/TLS (443).`, 'warn');
    }

    try { pc.close(); } catch {}
  }

  // =========================
  // Drawing
  // =========================
  let drawCtx = null;
  let drawDown = false;
  let lastPt = null;

  function initDrawing() {
    const canvas = $('drawCanvas');
    drawCtx = canvas.getContext('2d');

    const toCanvasPt = (e) => {
      const rect = canvas.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
      const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);
      return {x,y};
    };

    const down = (e) => {
      e.preventDefault();
      drawDown = true;
      lastPt = toCanvasPt(e);
    };
    const up = (e) => {
      e.preventDefault();
      drawDown = false;
      lastPt = null;
    };
    const move = (e) => {
      if (!drawDown) return;
      e.preventDefault();
      const pt = toCanvasPt(e);
      if (!lastPt) { lastPt = pt; return; }
      drawCtx.lineCap = 'round';
      drawCtx.lineJoin = 'round';
      drawCtx.lineWidth = 6;
      drawCtx.strokeStyle = '#e8ecff';
      drawCtx.beginPath();
      drawCtx.moveTo(lastPt.x, lastPt.y);
      drawCtx.lineTo(pt.x, pt.y);
      drawCtx.stroke();
      lastPt = pt;
    };

    canvas.addEventListener('mousedown', down);
    canvas.addEventListener('mousemove', move);
    window.addEventListener('mouseup', up);

    canvas.addEventListener('touchstart', down, {passive:false});
    canvas.addEventListener('touchmove', move, {passive:false});
    window.addEventListener('touchend', up, {passive:false});
  }

  function openDraw() {
    $('drawModal').classList.add('open');
  }
  function closeDraw() {
    $('drawModal').classList.remove('open');
  }
  function clearDraw() {
    const canvas = $('drawCanvas');
    if (!drawCtx) return;
    drawCtx.clearRect(0,0,canvas.width,canvas.height);
  }

  async function sendDrawingAsPng() {
    const conn = getActiveConn();
    if (!activePeerId) { log('Select or connect to a peer first.', 'warn'); return; }
    if (!conn || !conn.open) { log('No active connection. Connect first.', 'warn'); return; }

    const canvas = $('drawCanvas');
    const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/png'));
    if (!blob) { log('Failed to export drawing.', 'bad'); return; }

    const file = new File([blob], `drawing-${Date.now()}.png`, {type:'image/png'});
    $('file').files = null;

    // Send like a normal file
    const id = crypto.randomUUID();
    const total = Math.ceil(file.size / FILE_CHUNK);

    pushMessage(activePeerId, { id, kind:'file', from:'me', name:file.name, size:file.size, mime:file.type, ts:Date.now() });
    sendJson(conn, { t:'fmeta', id, name:file.name, size:file.size, mime:file.type, total, enc: !!encryptionOn });

    let offset = 0;
    for (let seq = 0; seq < total; seq++) {
      const slice = file.slice(offset, offset + FILE_CHUNK);
      const buf = new Uint8Array(await slice.arrayBuffer());
      offset += FILE_CHUNK;
      if (encryptionOn) {
        const { nonceB64, boxU8 } = encryptBytes(buf);
        sendJson(conn, { t:'fchunk', id, seq, total, enc:true, nonce: nonceB64, box: boxU8.buffer });
      } else {
        sendJson(conn, { t:'fchunk', id, seq, total, enc:false, data: buf.buffer });
      }
      if (seq % 16 === 0) await new Promise(r => setTimeout(r, 0));
    }
    sendJson(conn, { t:'fend', id });
    log('Drawing sent as PNG.', 'good');
  }

  // =========================
  // Controls
  // =========================
  function updateEncPill() {
    $('btnToggleEnc').textContent = `Encryption: ${encryptionOn ? 'ON' : 'OFF'}`;
    setPill('dotEnc','encState', encryptionOn ? 'good' : 'warn', `Encryption: ${encryptionOn ? 'ON' : 'OFF'}`);
  }

  function exportLog() {
    const content = logLines.map(x => x.line).join('\n');
    const blob = new Blob([content], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `pepechat-log-${APP_VERSION}-${Date.now()}.txt`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  function resetApp() {
    if (peer) {
      try { peer.destroy(); } catch {}
      peer = null;
    }
    chats.clear();
    activePeerId = null;
    // keep key by default; user can rotate
    LS.del('pepechat_chats');
    log('App reset: chats cleared. (Encryption key kept.)', 'warn');
    renderChatList();
    renderChat();
    setPill('dotPeer','peerState','warn','Not started');
  }

  // =========================
  // Init UI + load persisted data
  // =========================
  function refreshIceDropdown() {
    runtimeIceProfiles = buildRuntimeIceProfiles();
    const sel = $('iceProfile');
    sel.innerHTML = '';
    runtimeIceProfiles.forEach((p, idx) => {
      const o = document.createElement('option');
      o.value = String(idx);
      o.textContent = p.name;
      sel.appendChild(o);
    });
    loadIceProfileIndex();
    sel.value = String(Math.min(iceProfileIndex, runtimeIceProfiles.length-1));
  }

  function loadUiFromStorage() {
    const custom = LS.get('pepechat_custom_ice', '');
    $('customIce').value = custom || '';
    const sig = loadSigSettings();
    $('sigHost').value = sig.host;
    $('sigPort').value = String(sig.port);
    $('sigPath').value = sig.path;
    $('sigSecure').value = String(!!sig.secure);

    encryptionOn = LS.get('pepechat_enc_on', true);
    updateEncPill();
  }

  function bindUi() {
    $('btnRandom').addEventListener('click', () => {
      $('myId').value = randomUserId();
    });

    $('btnStart').addEventListener('click', async () => {
      await startPeer(null);
    });

    $('btnConnect').addEventListener('click', () => {
      const id = $('connectId').value.trim();
      connectWithIceFallback(id);
    });

    $('btnQR').addEventListener('click', () => {
      if ($('qrArea').style.display === 'none') openQrArea();
      else closeQrArea();
    });

    $('btnCopyInvite').addEventListener('click', async () => {
      const url = $('inviteUrl').value;
      try { await navigator.clipboard.writeText(url); log('Invite URL copied.', 'good'); }
      catch { log('Failed to copy to clipboard.', 'warn'); }
    });

    $('btnNewKey').addEventListener('click', () => rotateRoomKey());

    $('btnToggleEnc').addEventListener('click', () => {
      encryptionOn = !encryptionOn;
      LS.set('pepechat_enc_on', encryptionOn);
      updateEncPill();
      log(`Encryption toggled: ${encryptionOn ? 'ON' : 'OFF'}`);
    });

    $('btnRotateKey').addEventListener('click', () => rotateRoomKey());

    $('btnSend').addEventListener('click', sendText);
    $('msg').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendText();
    });

    $('btnSendFile').addEventListener('click', sendFile);

    $('iceProfile').addEventListener('change', () => {
      applyIceProfileByIndex(parseInt($('iceProfile').value,10) || 0, 'manual-select');
    });

    $('btnTryNextIce').addEventListener('click', () => {
      runtimeIceProfiles = buildRuntimeIceProfiles();
      const next = (iceProfileIndex + 1) % runtimeIceProfiles.length;
      applyIceProfileByIndex(next, 'manual-next');
      log('If a connection was failing, try reconnecting now.', 'warn');
    });

    $('btnIceProbe').addEventListener('click', probeCurrentIceProfile);

    $('btnSaveCustomIce').addEventListener('click', () => {
      LS.set('pepechat_custom_ice', $('customIce').value || '');
      refreshIceDropdown();
      applyIceProfileByIndex(0, 'custom-ice-saved');
      log('Saved custom ICE. The "Custom" profiles are now available at the top.', 'good');
    });

    $('btnClearCustomIce').addEventListener('click', () => {
      $('customIce').value = '';
      LS.set('pepechat_custom_ice', '');
      refreshIceDropdown();
      applyIceProfileByIndex(0, 'custom-ice-cleared');
      log('Cleared custom ICE.', 'warn');
    });

    $('btnSaveSig').addEventListener('click', () => {
      const s = {
        host: $('sigHost').value.trim() || '0.peerjs.com',
        port: parseInt($('sigPort').value,10) || 443,
        path: $('sigPath').value.trim() || '/',
        secure: $('sigSecure').value === 'true'
      };
      saveSigSettings(s);
      log(`Saved signaling server settings: ${s.secure?'wss':'ws'}://${s.host}:${s.port}${s.path}`);
      log('Restart PeerJS to apply signaling changes.', 'warn');
    });

    $('btnResetSig').addEventListener('click', () => {
      saveSigSettings({ host:'0.peerjs.com', port:443, path:'/', secure:true });
      loadUiFromStorage();
      log('Signaling settings reset to defaults. Restart PeerJS to apply.', 'warn');
    });

    $('btnExportLog').addEventListener('click', exportLog);
    $('btnResetApp').addEventListener('click', resetApp);

    // Drawing modal
    $('btnDraw').addEventListener('click', openDraw);
    $('btnCloseDraw').addEventListener('click', closeDraw);
    $('btnClearDraw').addEventListener('click', clearDraw);
    $('btnSendDraw').addEventListener('click', async () => {
      await sendDrawingAsPng();
      closeDraw();
    });

    // Close modal on backdrop click
    $('drawModal').addEventListener('click', (e) => {
      if (e.target === $('drawModal')) closeDraw();
    });
  }

  // =========================
  // Boot
  // =========================
  function boot() {
    loadChatsFromStorage();
    renderChatList();
    renderChat();

    loadUiFromStorage();
    refreshIceDropdown();

    // WebRTC availability
    if (isWebrtcAvailable()) setPill('dotWebrtc','webrtcState','good','WebRTC: available');
    else setPill('dotWebrtc','webrtcState','bad','WebRTC: unavailable');

    // Ensure key exists
    ensureRoomKey();
    updateEncPill();

    // Drawing init (fix: ensure drawCtx exists)
    initDrawing();

    // If URL requests auto-start (connect param), start peer with random id
    const url = new URL(window.location.href);
    if (url.searchParams.get('connect') && !peer) {
      $('myId').value = randomUserId();
      startPeer(null);
    }

    log(`PepeChat ${APP_VERSION} loaded.`);
  }

  document.addEventListener('DOMContentLoaded', () => {
    bindUi();
    boot();
  });

})();
</script>
</body>
</html>
